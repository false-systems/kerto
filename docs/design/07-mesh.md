# KERTO — Distributed Mesh Design

## ADR-007: Kerto-to-Kerto Knowledge Mesh

**Status:** Proposed
**Context:** KERTO is local-first, but developer teams need shared knowledge. Rather than a central server, KERTO nodes connect directly via BEAM distribution with mutual TLS authentication. Knowledge flows as occurrences — each node ingests independently.

## The Problem

A solo developer's KERTO accumulates useful knowledge: "auth.go breaks login_test," "we decided JWT over sessions." But this knowledge is trapped on one machine. When Developer B touches auth.go, they have no idea.

Git-shared `graph.json` (ADR-002) partially solves this, but it's batch (commit-time only), merge-conflict-prone, and can't share knowledge in real time during active development sessions.

## The Solution: BEAM Mesh

KERTO nodes connect directly. No central server. No API layer. Just BEAM distribution with mTLS.

```
Kerto@dev-a ←──mTLS/BEAM──→ Kerto@dev-b
     ↑                            ↑
  local CI / git / agents      local CI / git / agents
```

### Why BEAM Is the Right Tool

| Need | BEAM gives you | Alternative would require |
|------|---------------|-------------------------|
| Node discovery | `Node.connect/1` | Custom service discovery |
| Message passing | Built-in, location-transparent | gRPC/HTTP client + server |
| Reconnection | `Node.monitor/1`, auto-retry | Connection pool, health checks |
| Concurrency | Process-per-peer, no locks | Thread pool, mutex management |
| Auth | `inet_tls_dist` (native TLS) | TLS termination proxy |
| Partial failure | "Let it crash" per-peer | Circuit breakers, retry logic |

Zero external dependencies. Zero new protocols. The BEAM runtime handles everything.

## Architecture

### Revised Dependency Hierarchy

```
Level 0: lib/kerto/graph/           — Pure domain (done)
Level 1: lib/kerto/ingestion/       — Occurrences → graph ops (done)
         lib/kerto/rendering/       — Graph → natural language (done)
Level 2: lib/kerto/engine/          — ETS graph, decay timer, occurrence log
Level 3: lib/kerto/mesh/            — Identity, auth, sync, discovery
Level 4: lib/kerto/interface/       — MCP server, CLI, application
```

Level 3 (Mesh) depends on Level 2 (needs the occurrence log for replay) but is below Level 4 (Interface wires everything together).

### Module Layout

```
lib/kerto/mesh/
├── identity.ex          — Node keypair generation, cert requests
├── authority.ex         — Team CA: sign certs, verify, revoke
├── transport.ex         — Configure BEAM TLS distribution
├── peer.ex              — Per-peer GenServer (sync state machine)
├── sync.ex              — Occurrence exchange protocol
├── discovery.ex         — mDNS (LAN) + explicit (remote) discovery
└── mesh.ex              — Supervisor, public API
```

## Authentication: Mutual TLS

### Why mTLS, Not Erlang Cookies

Erlang's default auth is a shared cookie — a plaintext string. Anyone with the cookie connects as a fully trusted node. This is unacceptable for a product.

mTLS gives:
- **Cryptographic identity** — each node proves who it is
- **Team boundary** — only certs signed by your team's CA connect
- **Revocation** — remove a developer's cert without changing everyone's config
- **Transport encryption** — all BEAM messages encrypted (occurrences contain code paths, decisions)

### Certificate Hierarchy

```
Team CA (ed25519, generated by `kerto team init`)
│
├── signs → dev-a.crt    (Developer A's KERTO node)
├── signs → dev-b.crt    (Developer B's KERTO node)
└── signs → ci-node.crt  (CI server's KERTO node)

Stored in:
~/.kerto/
├── ca.crt               — Team CA public cert (shared, committed to team repo)
├── node.key             — This node's private key (NEVER shared)
├── node.crt             — This node's certificate (signed by CA)
└── peers/               — Known peer certificates (optional, for pinning)
```

### Setup Flow

```bash
# 1. Team lead creates the CA (once)
kerto team init
# → generates ~/.kerto/ca.key + ~/.kerto/ca.crt
# → ca.crt goes in team repo or shared config

# 2. Each developer joins
kerto team join --ca-cert <path-to-ca.crt>
# → generates ~/.kerto/node.key (local)
# → generates CSR
# → prints CSR for team lead to sign

# 3. Team lead signs
kerto team sign <csr-file> --name "dev-a"
# → produces dev-a.crt
# → developer saves as ~/.kerto/node.crt

# 4. Connect
kerto mesh start
# → BEAM starts with TLS distribution
# → auto-discovers peers on LAN via mDNS
```

### BEAM TLS Distribution Configuration

```elixir
# Generated by Kerto.Mesh.Transport at startup
# Passed to :net_kernel via vm.args or runtime config

ssl_dist_optfile = Path.join(kerto_home, "ssl_dist.conf")

File.write!(ssl_dist_optfile, """
[{server, [
  {certfile, "#{node_crt}"},
  {keyfile, "#{node_key}"},
  {cacertfile, "#{ca_crt}"},
  {verify, verify_peer},
  {fail_if_no_peer_cert, true},
  {secure_renegotiate, true},
  {versions, ['tlsv1.3']}
]},
{client, [
  {certfile, "#{node_crt}"},
  {keyfile, "#{node_key}"},
  {cacertfile, "#{ca_crt}"},
  {verify, verify_peer},
  {secure_renegotiate, true},
  {versions, ['tlsv1.3']}
]}].
""")
```

Both sides verify certificates. TLS 1.3 only. No fallback.

## Discovery

### Two Modes

**mDNS (LAN — automatic)**

KERTO announces itself via mDNS/DNS-SD on the local network. Other KERTO nodes discover it automatically.

```
Service type: _kerto._tcp.local
TXT records:
  team=<ca-fingerprint-first-8-chars>
  node=<node-name>
  port=<dist-port>
```

The `team` field is the first 8 characters of the CA certificate fingerprint. Nodes only attempt connection to peers with the same team fingerprint. This prevents cross-team discovery noise without leaking sensitive data.

**Explicit (remote — manual)**

```bash
kerto mesh connect kerto@192.168.1.42
# or in config
kerto mesh add-peer kerto@dev-b.example.com
```

Explicit peers are stored in `~/.kerto/peers.conf` and reconnected on startup.

### Discovery Flow

```
1. KERTO starts → announces on mDNS with team fingerprint
2. Discovers peer announcement → checks team fingerprint match
3. Fingerprint matches → attempts BEAM TLS connection
4. mTLS handshake → both sides verify CA signature
5. Connected → starts sync protocol
```

## Sync Protocol

### Design Principles

- **Occurrences are the sync unit** — not the graph, not individual nodes
- **Full replay on connect** — exchange all occurrences since last sync point
- **Idempotent** — replaying the same occurrence twice produces the same graph state (EWMA + content-addressed identity)
- **Unidirectional messages** — each side pushes its occurrences, no request/response
- **Eventually consistent** — graphs may differ briefly, converge after sync

### Sync State Machine (per peer)

```
┌──────────┐     connect      ┌────────────┐
│          │ ──────────────→  │            │
│  Idle    │                  │  Handshake │
│          │ ←────────────    │            │
└──────────┘   disconnect     └─────┬──────┘
                                    │ exchange sync points
                                    ▼
                              ┌────────────┐
                              │            │
                              │  Replaying │ ← exchange occurrences
                              │            │   since last sync point
                              └─────┬──────┘
                                    │ replay complete
                                    ▼
                              ┌────────────┐
                              │            │  new occurrence
                              │  Live      │ ←──────────────
                              │            │  forward immediately
                              └────────────┘
```

### Sync Point

Each peer pair maintains a **sync point** — the ULID of the last occurrence successfully exchanged. Stored locally in `~/.kerto/sync_points.json`:

```json
{
  "kerto@dev-b": "01JKXF...",
  "kerto@dev-c": "01JKXE..."
}
```

### Replay Protocol

```
A connects to B:

A → B: {:sync_hello, my_sync_point_for_b, my_node_name}
B → A: {:sync_hello, my_sync_point_for_a, my_node_name}

A sends all occurrences with ULID > B's sync point for A
B sends all occurrences with ULID > A's sync point for B

Both sides:
1. Receive occurrence
2. Run through Extraction dispatcher
3. Apply ops to local graph
4. Update sync point

After replay completes:
A → B: {:sync_live}
B → A: {:sync_live}

Now in live mode — new local occurrences are forwarded immediately.
```

### What Gets Synced

| Occurrence Type | Synced? | Rationale |
|----------------|---------|-----------|
| `ci.run.failed` | Yes | CI failures affect everyone |
| `ci.run.passed` | Yes | Counter-evidence is important |
| `vcs.commit` | Yes | Co-change patterns are universal |
| `context.learning` | Yes | Human knowledge is high-value |
| `context.decision` | Yes | Decisions must be team-wide |
| `context.pattern` | No | Derived — each node detects its own patterns |
| `context.query` | No | Audit trail, node-local |

### Conflict Resolution

There are no conflicts. By design:

1. **Content-addressed identity** — same file = same node ID everywhere
2. **EWMA is commutative** — order of observations doesn't matter for convergence
3. **Evidence accumulates** — both sides' evidence is preserved
4. **Decay is local** — each node's decay timer runs independently (graphs may differ slightly in weights, but converge to same shape)

If A says "auth.go breaks tests" (3 observations) and B says "auth.go breaks tests" (5 observations), after sync both have 8 observations and a higher weight. No merge logic needed.

## Supervision Tree Addition

```
Kerto.Application
│
├── ... (existing Level 2 infrastructure) ...
│
├── Kerto.Mesh.Supervisor (rest_for_one)
│   │
│   ├── Kerto.Mesh.Transport
│   │   (GenServer — configures BEAM TLS dist, starts :net_kernel)
│   │
│   ├── Kerto.Mesh.Discovery
│   │   (GenServer — mDNS announcements + listener, explicit peer list)
│   │
│   └── Kerto.Mesh.PeerSupervisor (DynamicSupervisor)
│       │
│       ├── Kerto.Mesh.Peer (GenServer — one per connected peer)
│       │   Manages sync state machine for kerto@dev-b
│       │
│       └── Kerto.Mesh.Peer (GenServer — one per connected peer)
│           Manages sync state machine for kerto@dev-c
```

`rest_for_one` strategy: if Transport crashes, Discovery and all Peers restart (TLS config is gone, need to re-establish).

## Security Considerations

### Threat Model

| Threat | Mitigation |
|--------|-----------|
| Unauthorized node joins mesh | mTLS — must have cert signed by team CA |
| Eavesdropping on sync traffic | TLS 1.3 encryption on all BEAM messages |
| Malicious occurrence injection | Occurrences carry source identity; trust is per-team |
| Stolen node key | Revoke cert: `kerto team revoke dev-a` → CRL distributed to peers |
| CA key compromise | Rotate CA: `kerto team rotate` → re-signs all node certs |
| Replay attacks | ULID-based sync points prevent duplicate processing |

### What Kerto Does NOT Protect Against

- A trusted team member sending bad data (trust boundary is the team)
- Side-channel attacks on BEAM internals
- Physical access to a developer's machine

### Private Key Protection

- `~/.kerto/node.key` is `chmod 600` (owner-only)
- Never transmitted, never synced, never committed
- CA private key (`~/.kerto/ca.key`) exists only on the team lead's machine

## Configuration

### Mesh Defaults

```elixir
%{
  mesh_enabled: false,                    # Opt-in
  mesh_mdns: true,                        # Auto-discover on LAN
  mesh_explicit_peers: [],                # Manual peer list
  mesh_sync_batch_size: 100,              # Occurrences per sync message
  mesh_reconnect_interval_ms: 5_000,      # Retry failed connections
  mesh_max_peers: 20,                     # Safety limit
  mesh_tls_versions: [:"tlsv1.3"]        # No downgrade
}
```

### Per-Project Override

```elixir
# .kerto/config.exs
%{
  mesh_enabled: true,
  mesh_explicit_peers: ["kerto@ci.internal"]
}
```

## CLI Commands

```bash
# Team management
kerto team init                    # Create team CA
kerto team join --ca-cert <path>   # Generate node cert request
kerto team sign <csr> --name <n>   # Sign a node's CSR
kerto team revoke <name>           # Revoke a node's cert
kerto team list                    # List all signed certs

# Mesh operations
kerto mesh start                   # Start mesh (mDNS + explicit peers)
kerto mesh stop                    # Disconnect from all peers
kerto mesh status                  # Show connected peers, sync state
kerto mesh connect <node>          # Connect to explicit peer
kerto mesh add-peer <node>         # Add persistent peer
kerto mesh remove-peer <node>      # Remove persistent peer
```

## What This Enables

### Scenario: Developer A Discovers a Bug Pattern

```
10:00  Dev A's CI fails — auth.go breaks login_test
       A's KERTO: {auth.go --breaks--> login_test, weight: 0.5}

10:05  Mesh syncs occurrence to Dev B
       B's KERTO: {auth.go --breaks--> login_test, weight: 0.5}

10:30  Dev B's CI fails — same pattern
       B's KERTO: {auth.go --breaks--> login_test, weight: 0.65}
       Syncs back to A
       A's KERTO: {auth.go --breaks--> login_test, weight: 0.65}

11:00  Dev B asks Claude to modify auth.go
       Claude queries KERTO → gets warning:
       "Caution: auth.go breaks login_test.go (weight 0.65, 2 observations)"
       Claude is careful with the change.
```

No central server. No Slack message. No "hey, be careful with auth.go." The knowledge flows through the mesh automatically.

### Scenario: Architectural Decision Propagates

```
Dev A records: kerto decide --subject "auth" --target "JWT" "stateless requirement"
→ Syncs to all peers in seconds
→ Every developer's AI agent now knows: "auth module decided JWT"
→ No agent will suggest sessions for auth
```

## Implementation Order

1. `Mesh.Identity` — keypair generation, CSR creation
2. `Mesh.Authority` — CA operations (init, sign, verify, revoke)
3. `Mesh.Transport` — BEAM TLS distribution configuration
4. `Mesh.Sync` — occurrence exchange protocol (pure functions first)
5. `Mesh.Peer` — per-peer GenServer (sync state machine)
6. `Mesh.Discovery` — mDNS + explicit peer management
7. `Mesh.Supervisor` — wire it all together
8. CLI commands — `kerto team *`, `kerto mesh *`

Modules 1-4 are heavily testable with pure functions. Modules 5-7 need integration tests with actual BEAM distribution. Module 8 is interface wiring.

## Dependencies

- **Zero new deps for core mesh** — `:crypto`, `:ssl`, `:public_key` are all OTP stdlib
- **mDNS** — either `:mdns_lite` (small hex dep) or raw `:gen_udp` multicast (zero deps, more code)
- Decision: start with explicit-only discovery, add mDNS as a second step

## Non-Goals (For Now)

- **Access control within a team** — all connected peers are equal (no read-only nodes)
- **Selective sync** — all occurrence types sync (except derived/audit)
- **Cross-team mesh** — one CA = one mesh boundary
- **NAT traversal** — explicit peers must be reachable (VPN or same network)
- **Persistence of peer state** — sync points survive restarts, but in-flight messages may be lost (replay handles this)
